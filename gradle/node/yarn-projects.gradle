import java.time.Instant

// Configure node/ yarn projects

configure([
    project(":dcs:contexts:frontend"),
    project(":doc")
]) {

  apply plugin: 'base'
  apply plugin: 'com.github.node-gradle.node'

  ext {
    yarnEnv = [
      'REACT_APP_VERSION'   : rootProject.replaceTokens['product.version'],
      //'REACT_APP_BUILD_DATE': rootProject.replaceTokens['product.buildDate'],
      'REACT_APP_BUILD_DATE': Instant.now().toString(),
      'REACT_APP_GIT_REV'   : rootProject.replaceTokens['product.gitrev']
    ]
  }

  configurations {
    it.default.extendsFrom archives
  }

  // Change the default build directory for gradle so that
  // it doesn't conflict with npm builds (webpack uses 'build' by default).
  buildDir = file("build-gradle")

  // Configure node and yarn versions.
  node {
    version = "${rootProject.versions.node}"
    yarnVersion = "${rootProject.versions.yarn}"
    download = true
  }

  task yarnInstall(type: YarnTask) {
    group 'build'

    inputs.file('package.json')
    inputs.file('yarn.lock')

    outputs.upToDateWhen {
      return project.file('node_modules').exists()
    }
    outputs.file('node_modules/.yarn-integrity')

    args = [
        'install',
        '--frozen-lockfile'
    ]
  }

  task yarnBuild(type: YarnTask) {
    group 'build'
    dependsOn yarnInstall

    inputs.file('package.json')
    inputs.file('yarn.lock')
    inputs.files { jsSources }

    outputs.dir { jsBuildDir }

    def nonInputProperties = ["REACT_APP_BUILD_DATE", "REACT_APP_GIT_REV"] as Set

    afterEvaluate {
      project.properties.each { k,v ->
        if (k.startsWith("REACT_APP_")) {
          yarnEnv.put(k, v)
        }
      }

      System.getenv().each {k, v ->
        if (k.startsWith("REACT_APP_")) {
          yarnEnv.put(k, v)
        }
      }
    }

    environment.putAll(project.provider {
      return yarnEnv.findAll { k,v -> !nonInputProperties.contains(k) }
          .collectEntries { k,v -> [k, Objects.toString(v)] }
    })

    // Pass non-input trigering environment variables separately so that builds
    // are not triggered when they change.
    // https://github.com/node-gradle/gradle-node-plugin/issues/187
    execOverrides { ExecSpec spec ->
      yarnEnv.findAll { k, v -> nonInputProperties.contains(k) }.each { k, v ->
        spec.environment(k, v)
      }

      // Dump environment variables used, for debugging purposes.
      spec.environment.each { k,v ->
        if (yarnEnv.containsKey(k)) {
          logger.lifecycle("Using yarn env variable $k=$v")
        }
      }
    }

    args = [
        'build'
    ]
  }

  task fastBuild {
    doFirst {
      logger.warn("Omitting full yarn build in fast build: ${project.path}")
    }
  }

  artifacts {
    archives provider { jsBuildDir }, {
      if (project.hasProperty("fast")) {
        builtBy fastBuild
      } else {
        builtBy yarnBuild
      }
    }
  }

  assemble.dependsOn configurations.archives

  clean {
    doLast {
      project.delete project.files(project.jsBuildDir)
    }
  }

  task cleanNodeDirs(type: Delete) {
    delete ".gradle"
    delete "node_modules"
  }

  cleanall.dependsOn cleanNodeDirs
}

// Yarn install creates many problems when multiple instances try to run concurrently. Enforce
// sequential ordering here.
afterEvaluate {
  rootProject.tasks.create("yarnOrdering")

  def sequence = [
  ]

  [
    ":dcs:contexts:frontend:yarnInstall",
    ":dcs:contexts:frontend:yarnBuild",
    ":doc:yarnInstall",
    ":doc:yarnBuild",
    ":yarnOrdering"
  ].each { path ->
    def task = tasks.findByPath(path)
    task.mustRunAfter(sequence)
    sequence += task
  }
}
