<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC 
    "-//Dawid Weiss//DTD DocBook V3.1-Based Extension for XML and graphics inclusion//EN"
    "http://www.cs.put.poznan.pl/dweiss/dtd/dweiss-docbook-extensions.dtd" [
<!ENTITY % isopub SYSTEM "iso-pub.ent"> 
%isopub;
<!ENTITY % local SYSTEM "local-entities.ent">
%local;
]>
  
<chapter id="chapter:architecture">
    <title>Remote components architecture</title>

    <section id="sect:components-and-data-flow">
        <title>Components and data flow</title>

        <!-- {{{ -->
        <para>
        &carrot;'s architecture is based on certain definitions of <glossterm>data
        exchange formats</glossterm> and interaction among <glossterm>components</glossterm>.
        </para>

        <pasteFigure src="components-dataflow.png" width="4in">
        Components and data flow in &carrot;
        </pasteFigure>

        <para>
        There are four fundamental component types in the framework: input component,
        output component, filter component and controller component. A typical flow of
        information among them is presented in 
        <xref linkend="figure:components-dataflow" />. 
        Central to this concept is the controller component, which transforms
        input stimuli (like user's search query) into a format acceptable by
        the input components and then mediates in data exchange among filter components,
        eventually returning the final reasult back to the outside world
        using the output component. The last component is usually some sort of visualization
        of the result (in case of search results clustering, presentation of the discovered
        groups of documents).
        </para>

        <para>
        An established <glossterm>process</glossterm> of data flow from the search
        request to the final output is one of &carrot;'s strongest features. 
        Designers have the freedom to make up their own intermediate data
        formats (passed between components), but they can still use the controller
        component and any other part of the system. Obviously, components
        combined together into a processing chain must be able to interpret each other's
        result.
        </para>

        <para>
        One could notice that this results in a seemingly excessive communication between the controller
        and other components in a processing chain. This could be replaced by a &quot;waterfal&quot;
        scheme, where every component's output would be directly passed to the following
        component's input. Such situation is of course possible, but it would require
        that information about the entire process is embedded in the request at the beginning
        and that components share the functionality of the controller (i.e. send data processing
        requests to other components).  
        We decided to make component designers' life easier and went for an easier &quot;centralized&quot;
        model, where all information is mediated by the controller component. &http; protocol
        used for data exchange also supports our choice, as it is inherently bound to 
        query-response paradigm.
        </para>
        
        <note>
            <para>
            <link linkend="sect:local-interfaces">Local interfaces</link> are the performance-oriented design one can switch
            to when remote components don't meet the speed requirements.
            </para>
        </note>
        <!-- }}} -->
    </section>

    <section id="sect:communication-method">
        <title>Communication methods</title>
        <!-- {{{ -->       
        <para>
        In <xref linkend="sect:components-and-data-flow"/>, we described <emphasis>where</emphasis>
        data and processing takes place in the framework. This section explains
        <emphasis>how</emphasis> it is sent and received by individual components.
        </para>

        <para>
        Data exchange among &carrot;'s remote components is realized using
        &xml; files transferred over the network using &post; method of the &http; protocol.
        </para>

        <section id="sect:http-communication">
            <title>&http; &post; communication mode</title>
            <!-- {{{ -->
            
            <para>
            &carrot;'s data is sent over &http; connection. The following
            requirements must be fulfilled:

                <itemizedlist>
                    <listitem>
                    <para>
                        The data stream (query for input components,
                        result stream for filters and outputs), should be sent
                        as <emphasis>a parameter</emphasis> of a &http; &post; request.
                        The parameter's name should be <parameter>carrot-request</parameter> 
                        for input components and  
                        <parameter>carrot-xchange-data</parameter> for
                        filter and output components.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    &http; &get; request is reserved for future extensions of the framework.
                    Service &url; of a component should not use it for any private 
                    communication.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    &http; &post; request parameters (&xml; files)
                    must be encoded using &utf8; character
                    encoding. &http; request/ response content type should also be
                    set to &utf8;, although since the XML file is a parameter of the
                    &post; request, it must be properly escaped to conform to HTTP specification anyway.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    Normal &http; <parameter>Content-encoding</parameter> headers
                    should be respected. In particular, <acronym>GZIP</acronym>
                    compression, if supported by the caller (controller component),
                    should be utilized to save network bandwidth.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    Successful processing should be indicated using standard
                    &http; headers and return codes. In particular, erraneous execution
                    should also be signalled to the caller (controller) using &http; error codes.
                    </para>
                    </listitem>
                </itemizedlist>
            </para>

            <para>
            By implicit assumption, all components that expose
            a &http; &post; interface must also define at least one Uniform
            Resource Locator (&url;s) where their services will be accessible to
            other components. These service &url;s are then used in specifying
            a component descriptor file.
            </para>

            <para>
            The controller component guarantees no special handling
            in case of erraneous execution of a
            chained component. In general, an empty, or corrupted response
            stream indicates such situation, but the controller may
            just propagate such empty response to components further down the chain.
            However, if any component sends an error &http; response header, the
            controller component will interrupt any remaining processing and
            signal the problem to the outside environment (user).
            </para>
            
            <important>
                <para>The guidelines above are applicable for all types of &http;
                communication among the remote components. Particular component types
                (such as filter or input components) have additional requirements
                &emsp; see section <xref linkend="sect:input-component"/> and
                <xref linkend="sect:filter-components" /></para>
            </important>

        </section>
        <!-- }}} -->
    </section>    
    <!-- }}} -->

    <section id="sect:input-component">
        <title>Input component type</title>
        <!-- {{{ -->
        <para>
        The input component is in charge of accepting a <glossterm>query
        request</glossterm> from the controller. The query request
        may be any data stream and the input component should signal
        an error if it cannot parse and respond to the query.
        At the moment of writing, the only request format
        detected by the implemented input components is described 
        in section <xref linkend="sect:mime:x-carrot-clustering-input-query" />.
        </para>
        <!-- }}} -->
    </section>
    
    
    <section id="sect:filter-components">
        <title>Filter components</title>
        <!-- {{{ -->
        <para>
        Filter components are used to transform one result data set into another. As
        mentioned in section <xref linkend="sect:components-and-data-flow"/>, the exact format
        of input and output data of a filter component is not specified by the
        framework, but depends on the application.
        </para>
        
        <section>
            <title>Filter components and &http; data exchange</title>

            <para>
            The XML data stream must be sent as a parameter of &http; &post; request named
            <parameter>carrot-xchange-data</parameter>. 
            </para>
            
            <para>
            The same POST request, which carries &carrot; data can also contain other
            parameters, which can be used to customize processing done by the component.
            It is important to send any extra &http; &post; parameters affecting the component
            before <parameter>carrot-xchange-data</parameter> parameter is sent.
            </para>
            
            <para>
            An example of a valid &http; &post; request specifying
            optional parameter <parameter>myparameter</parameter> is shown in
            <xref linkend="listing:post-request"/>.    
            </para>

            <example id="listing:post-request">
                <title>
                A fragment of a &post; request to a service running at &url;
                <parameter>http://localhost:8080/myfilter</parameter>, with additional parameter
                <parameter>myparameter</parameter> set to <literal>myvalue</literal>
                </title>
                <programlisting><![CDATA[@insert-file.head-of-post-request@]]></programlisting>
            </example>
        </section>
        <!-- }}} -->
    </section>
    
    <section id="sect:output-components">
        <title>Output component type</title>
        <!-- {{{ -->
        <para>
        An output component type is responsible for converting the final data stream into
        some content, which can be returned to the outside environment. Output components
        may also perform additional tasks, not relevant to visualization of the result, like
        dumping the result to a database or sending a confirmation e-mail. Usually 
        the output component will turn the raw data processed by input and filter components
        into some content that can be interpreted by the user's browser.
        </para>

        <important>
            <para>
            Output component should declare an appropriate &http; <parameter>Content-type</parameter>
            header for the response stream (corresponding to the real nature of the returned data).
            </para>
        </important>
        <!-- }}} -->
    </section>

    <section id="sect:controller-components">
        <title>Controller component type</title>
        <!-- {{{ -->
        <para>
        A controller component is the heart of &carrot; framework. It drives the
        process of executing a query by redirecting data from the input, through a
        set of filters and finally to the output component. A controller is also in
        charge of interacting with the &quot;outside world&quot; environment &ndash; this can be
        anything from a set of shell scripts to a fully-fledged web based meta search engine.
        </para>

        <para>
        Controllers should expose information about
        <glossterm>processes</glossterm>. A process is a chain of
        components, starting with an input, ending at some output and having filters in
        between.
        </para>
        
        <!-- }}} -->
    </section>
</chapter>
