<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC 
    "-//Dawid Weiss//DTD DocBook V3.1-Based Extension for XML and graphics inclusion//EN" 
    "http://www.cs.put.poznan.pl/dweiss/dtd/dweiss-docbook-extensions.dtd" [
<!ENTITY % isopub SYSTEM "iso-pub.ent"> 
%isopub;
<!ENTITY % local SYSTEM "local-entities.ent">
%local;

]>

<chapter id="sect:contributing-to-carrot">
    <title>Contributing to &carrot;</title>

    <para>
    &carrot; is an open-source initiative. Everybody can see, use and modify the
    source code, but we strongly enourage you to join the development and contribute
    to the project instead of spawning your own.
    </para>
    
    
    <section id="sect:prerequisities">
        <title>Prerequisities</title>
        <!-- {{{ -->

        <section id="sect:getting-the-source-code">
            <title>Acquiring the source code</title>
            <!-- {{{ -->
            <para>
            Refer to on-line instructions at
            <ulink url="http://www.cs.put.poznan.pl/dweiss/carrot/xml/index.xml?lang=en" />.
            </para>

            <!-- }}} -->
        </section>

        <section id="sect:repository-structure">
            <title>CVS repository structure</title>
            <!-- {{{ -->
            <para>
            The CVS is organized according to the following scheme:
            </para>
            
            <informalexample id="listing:cvs-structure">
                <programlisting><![CDATA[@insert-file.cvs-structure@]]></programlisting>
            </informalexample>
    
            <para>
            This repository structure is of course apt to change and be refactored
            as new things are added, or ideology changes. Pay attention to
            the messages on project mailing list.
            </para>
            <!-- }}} -->
        </section>
        
        <!-- }}} -->
    </section>
    
    <section id="sect:common-management-activities">
        <title>Common management activities</title>
        <!-- {{{ -->
        <section id="sect:adding-new-components">
            <title>Adding new components</title>
            <!-- {{{ -->
            <para>
            &carrot; components do not have to be placed in the common project structure
            maintained in SourceForge's &cvs;. It is strongly encouraged though as common repository
            facilitates build and distribution process. Please refer to <xref linkend="sect:build-files" />
            for a description of how build files for components should be organized.
            </para>

            <para>
            New components should be placed (depending on their type), in <filename>inputs</filename>,
            <filename>outputs</filename> or <filename>controllers</filename> sections of the CVS structure. If
            the component is developed in Java, use of shared libraries and template methods
            is strongly encouraged (refer to section <xref linkend="sect:carrot-shared-lib"/>).
            The common Java library (<filename>carrot2-shared-lib.jar</filename>) is always available in a compiled
            form in <filename>runtime/shared/lib</filename> and
            should not be referenced directly from source code folder.
            </para>
            
            <tip>
            <para>
            For every type of component there is always an template example showing basic
            steps required to set up a component in the servlet container's environment.
            Please refer to <xref linkend="sect:carrot-shared-lib"/>,
            where these examples are discussed.
            </para>
            </tip>
            <!-- }}} -->
        </section>
        
        <section id="sect:build-files">
            <title>Build files</title>
            <!-- {{{ -->
            <para>
            The basic goal is to have a full &carrot; distribution built automatically using 
            one &ant; script at the top level of &cvs; repository checkout.
            The &cvs; also includes a runtime environment, where compiled components are placed
            upon a successfull build (see <xref linkend="sect:runtimeenvironment" />).
            In order to achieve this and relieve component designers from the need of updating
            the main build script when components are added or removed, certain &ant;
            target names have been <emphasis>restricted</emphasis> in the project. We
            also define certain properties that a build file should recognize and use.
            All these are described below:
            </para>
            
            <simplesect>
                <title>Overriden properties</title>
                
                <itemizedlist>
                    <listitem>
                        <para>
                        <literal>distribution.dir</literal> property.
                        </para>
                        <para>
                        This property is set by the main build file and points to a directory where
                        the final <filename>WAR</filename> file should be placed upon successfull
                        compilation.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                        <literal>carrot2.cvs.dir</literal> property.
                        </para>
                        <para>
                        This property points to the base directory of a full &cvs; checkout
                        of the &carrot; project. This can be used, for example, to define
                        paths to shared libraries (although dependency files are preferred
                        &mdash; see <link linkend="sect:dependency-files">
                        section about dependency files</link>.
                        </para>
                    </listitem>
                </itemizedlist>
            </simplesect>



            <simplesect>
                <title><literal>clean</literal> target</title>

                <para>
                In every component build file, this task should implement the following functionality:
                </para>

                <itemizedlist>
                    <listitem><para>
                    Delete any files and folders created during compilation or build phases.
                    </para></listitem>
                    
                    <listitem><para>
                    Delete any other files not present in the CVS structure, so that query
                    update with CVS repository does not yield unknown files in the local checkout.
                    </para></listitem>
                </itemizedlist>

                <important>
                <para><literal>clean</literal> task is invoked automatically on any <filename>build.xml</filename>
                file found in subfolders of <filename>components</filename> CVS module. Therefore you must ensure
                that it works properly before committing the build file into the shared CVS.
                </para>
                </important>

            </simplesect>
            
            <simplesect>
                <title><literal>build</literal> target</title>

                <para>
                <literal>build</literal> task is reserved for creating a web application archive of
                a component, or any other form of final deployment a component might have. For Java components,
                this usually involves creating a <filename>WAR</filename> archive and copying it to
                the <filename>/runtime/webapps</filename> folder of the local CVS checkout so that
                the component is automatically deployed upon runtime environment startup.
                </para>
                
                <important>
                <para>
                Unlike <literal>clean</literal> tasks, <literal>build</literal> targets are not
                invoked automatically from the common build script. Maintainer of a given component
                should send a request to include it to the build process to &carrot; project
                administrator. The component
                must be tested and working before it is included in the global build process.
                </para>
                </important>
            </simplesect>
            
            <!-- }}} -->
        </section>
        
        <section id="sect:dependency-files">
            <title>Managing component dependencies</title>
            <!-- {{{ -->
            <para>
            Components often rely on presence of other Open Source products
            and libraries (such as matrix computation packages, or logging frameworks).
            Libraries reused by more than one component are placed in
            <filename>lib</filename> folder of the main &cvs; module to save &cvs; space
            and avoid version conflicts. However, it would be difficult to track which
            component uses which libraries &mdash; for this reason, we have developed
            a simple &ant; task that analyzes <emphasis>dependency files</emphasis>
            and assembles a list of objects that a component needs.
            </para>
            
            <para>
            A dependency file is an &xml; file that declares the name of a component,
            names of the objects it delivers (usually none, but some components,
            such as the shared library, deliver a &jar; file) and finally, 
            names of other components that are required. A sample dependency file
            is shown <link linkend="listing:dep-file">below</link>.
            </para>
 
           <informalexample id="listing:dep-file">
                <programlisting><![CDATA[@insert-file.dep-file@]]></programlisting>
            </informalexample>
            
            <para>
            For other examples of dependency files, see <filename>*.dep</filename> files
            in the shared libraries folder (<filename>lib</filename> in the main &cvs;
            checkout directory).
            </para>
            
            <para>
            Special &ant; tasks must be added to the build file
            to utilize the dependency specification. For an example of how this is
            done, refer to any of the component build files already present in the
            &cvs; and look for targets named:
            <literal>generate.dependency.path</literal>,
            <literal>show.dependencies</literal> and <literal>collect.dependencies</literal>.
            </para>
            
            <note>
            <para>
            A refactoring is planned when one template build file will be used
            to build all components.
            </para>
            </note>
 
            <!-- }}} -->
        </section>

        <section id="sect:coding-standard">
            <title>Coding standard</title>
            <!-- {{{ -->
            <para>
            Java developers in &carrot; project should follow SUN's coding guidelines
            available at <ulink url="http://java.sun.com/docs/codeconv"/>,
            with exception to curly braces in class/ method/ conditions and loops &mdash; these
            should be aligned <emphasis>under</emphasis> each other (in the same column
            of the following
            line (see <xref linkend="listing:code-layout-example"/>).
            </para>
            
            <para>
            Please refrain from using tabs in your source code files. Use spaces and set
            indentation to 4 columns.
            </para>

            <example id="listing:code-layout-example">
                <title>
                A typical source code in the project. Note curly braces are <emphasis>under</emphasis> each other.
                </title>
                <programlisting><![CDATA[@insert-file.code-layout-example@]]></programlisting>
            </example>
            
            <note>
            <para>
            A sample <ulink url="http://jalopy.sourceforge.net/">Jalopy</ulink>
            code reformatting tool is included in the &cvs; &mdash; <filename>/misc/jalopy</filename>.
            </para>
            </note>
            <!-- }}} -->
        </section>        
       
        <section id="sect:logging-framework">
            <title>Logging framework</title>
            <!-- {{{ -->
            <para>
            It is suggested that &log4j; logging framework is used across
            all components to ensure a uniform log format. It is also supported by
            <link linkend="sect:log4j-init-support">the common
            &carrot; Java library</link>.
            
            Developers may choose other logging
            utilities according to their needs, but should avoid using console output
            (<methodname>System.out</methodname> and <methodname>System.err</methodname> objects).
            </para>

            <important>
            <para>
            In case &log4j; is used, make sure your code,
            or configuration properties <emphasis>do not override or alter</emphasis>
            the root logger object.
            </para>
            <para>
            &log4j; initialization is quite simple, but 
            to ensure similar approach among
            all components, it is strongly enouraged to use the abstract initialization
            methods defined in the shared Java library described in detail in
            <xref linkend="sect:log4j-init-support" />.
            </para>
            </important>
            
            <para>
            In-application loggers should be associated with Java classes
            facilitate debugging, refer to this code example:
            </para>
            
            <informalexample>
            <programlisting><![CDATA[
package com.mycompany;
public class MyClass
{
    private final static Logger log = Logger.getLogger( MyClass.class );
    
    // rest of class definition follows.
}
            ]]></programlisting>
            </informalexample>

            <para>
            In this example, the logger will have the name of a fully qualified Java class
            &ndash; <classname>com.mycompany.MyClass</classname>.
            </para>
            <para>
            The use of a logger object in &log4j; is quite simple. There are
            several levels of severity defined for log messages:
            <constant>FATAL</constant>,
            <constant>ERROR</constant>,
            <constant>WARN</constant>,
            <constant>INFO</constant>,
            <constant>DEBUG</constant>. A simple advice on which one to choose is to use <constant>FATAL</constant>
            level to indicate application must be exit, <constant>ERROR</constant> to signal a recoverable
            error, that the user (or administrator) should be notified about, <constant>WARN</constant> to signal
            a less important error, which can be overlooked, <constant>INFO</constant> and <constant>DEBUG</constant>
            levels for application-debugging only. For example:
            </para>
            
            <informalexample>
            <programlisting><![CDATA[
public byte [] readNBytesFromInputStream( InputStream stream, int n )
    throws IOException
{
    try
    {
        if (n > 1000 || n < 0)
        {
            log.error("Illegal parameter passed, n=" + n);
            throw new RuntimeException("Illegal parameter passed, n=" + n);
        }
        return stream.read( new byte[ n ] );
    }
    catch (IOException e)
    {
        log.warn("IO Error when reading stream.", e);
    }
}
            ]]></programlisting>
            </informalexample>
            <!-- }}} -->
        </section>
        
        <!-- }}} -->
    </section>
    
    
    <section id="sect:carrot-shared-lib">
        <title>&carrot; shared Java library</title>
        <!-- {{{ -->
        <para>
        Certain elements of &carrot; framework are a little tricky. For instance,
        handling &post; requests in Java is troublesome, since servlet specification does
        not include automatic methods for retrieving input arguments as streams. This,
        and other useful utilities have been compiled into a reusable library
        of utility classes. A JAR file containing this library should always be available in 
        <filename>runtime/shared/lib/carrot2-common.jar</filename>.
        </para>

        <para>
        The library is composed of several components (java packages), which are briefly
        described below (please consult JavaDocs for the most recent information).
        </para>


        <section id="sect:input-component-type-utilities">
            <title>Input component type utilities</title>
            <!-- {{{ -->
            <para>
            Package <classname>com.dawidweiss.carrot.input.*</classname>
            contains a generic servlet, which
            can be used to set up a web service and process &carrot; input requests. In
            order to do this, one must do one of the following:
            
            <itemizedlist>
            
                <listitem><para>
                Subclass <classname>InputRequestProcessor</classname> and override
                <methodname>processQuery</methodname> method. This method takes as an argument the
                user query, number of expected results, output <classname>Writer</classname>, where
                the result should be written to, and a <classname>HttpServletRequest</classname>
                object, which was used to activate processing.
                </para></listitem>
                
                <listitem><para>
                In web application descriptor file <filename>web.xml</filename>, add servlet
                mapping to the generic <classname>InputRequestProcessorServlet</classname>
                class and provide it with the name of your subclassed
                <classname>InputRequestProcessor</classname> (see <xref linkend="example:web-config-file-for-input-component" />).
        
                <example id="example:web-config-file-for-input-component">
                <title>A fragment of <filename>web.xml</filename> web application
                descriptor file, specifying processing class for an input component
                template servlet</title>
                <programlisting><![CDATA[
<servlet>
    <servlet-name>MyInputTypeComponent</servlet-name>
    <servlet-class>
        com.dawidweiss.carrot.input.InputRequestProcessorServlet
    </servlet-class>
    <init-param>
      <!-- This is where you specify your implementation class for the
           component -->
      <param-name>inputRequestProcessor</param-name>
      <param-value>com.mycompany.carrot.MyInputProcessor</param-value>
    </init-param>
</servlet>
             ]]></programlisting>
                </example>

                </para></listitem>
            
            </itemizedlist>            
            </para>

            <para>
            An example of this approach is presented in snippet generator component,
            which can be found in <filename>components/inputs/snippet-generator</filename>
            folder of the distribution.
            </para>

            <!-- }}} -->
        </section>
        
        <section id="sect:filter-and-output-component-type-utilities">
            <title>Filter and output component type utilities</title>
            <!-- {{{ -->
            <para>            
            Package <classname>com.dawidweiss.carrot.filter.*</classname>
            contains a generic servlet, which
            can be used to set up a web service and process &carrot; requests.
            Because filter and output components differ only in the format of returned data,
            the template classes may be reused for both types without much difference.
            </para>

            <para>
            In order to use the shared library, one should follow these steps:
            <itemizedlist>
                <listitem><para>
                    Subclass <classname>FilterRequestProcessor</classname> and override
                    <methodname>processFilterRequest</methodname> method. This method takes as an argument the
                    data stream to be processed, servlet &http; request and response which
                    caused the processing and a mapping of parameters, which were sent in
                    the &post; request <emphasis>before</emphasis>
                    the data stream occurred (refer to <xref linkend="sect:filter-components" />
                    for details).
                </para></listitem>
                <listitem><para>
                    In web application descriptor file (<classname>web.xml</classname>), add servlet
                    mapping to the generic <classname>FilterRequestProcessorServlet</classname>
                    class and provide it with the name of your subclassed
                    <classname>FilterRequestProcessor</classname>
                    (see <xref linkend="example:web-config-file-for-filter-component" />).
            
                    <example id="example:web-config-file-for-filter-component">
                    <title>A fragment of <filename>web.xml</filename> web application
                    descriptor file, specifying processing class for an output or filter 
                    type template servlet</title>
                    <programlisting><![CDATA[
<servlet>
  <servlet-name>TextOnly</servlet-name>
  <servlet-class>
    com.dawidweiss.carrot.filter.FilterRequestProcessorServlet
  </servlet-class>
  <init-param>
    <!-- This is where you should specify your component
         processing class -->
    <param-name>filterRequestProcessor</param-name>
    <param-value>
        com.dawidweiss.carrot.filter.textonly.TextOnlyFilter
    </param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
                    ]]></programlisting>
                    </example>
                </para></listitem>
            </itemizedlist>
            </para>
            
            <para>
            An example of this approach is presented in request filtering component,
            which can be found in <filename>components/filters/text-only</filename>
            folder of the distribution.
            </para>

            <!-- }}} -->
        </section>

        <section id="sect:log4j-init-support">
            <title>&log4j; initialization support</title>
            <!-- {{{ -->
            <para>        
            In order to simplify &log4j; initialization, a shared utility class
            <classname>Log4jStarter</classname>
            is provided. This class resides in <classname>com.dawidweiss.carrot.util</classname>
            package of the library and cannot be directly instantiated - use factory method for this
            purpose:
            <screen>Log4jStarter starter = com.dawidweiss.carrot.util.Log4jStarter.getLog4jStarter()</screen>
            </para>
            
            <para>
            Several methods are provided to facilitate log4j initialization:
            <itemizedlist>
                <listitem>
                    <para>
                        <returnvalue>void</returnvalue>
                        <function>initializeLog4j</function>()
                    </para>
                    <para>
                    This is the simplest method, which does the default initialization.
                    </para>
                </listitem>
                
                <listitem>
                    <para>
                        <returnvalue>void</returnvalue>
                        <function>initializeLog4j</function>(
                        <parameter>Properties p</parameter>)
                    </para>
                    <para>
                    This allows for full customization of log4j configuration. Property
                    file must contain valid log4j properties. Make sure root logger is not
                    overriden by any of them.
                    </para>
                </listitem>
                
                <listitem>
                    <para>
                        <returnvalue>void</returnvalue>
                        <function>initializeLog4j</function>(
                        <parameter>ServletConfig config</parameter>)
                    </para>
                    <para>
                    This is the recommended method for use in web applications (servlets).
                    </para>
                    <para>
                    A valid <classname>ServletConfig</classname> object should be passed
                    to this method, where the
                    web application descriptor file <filename>web.xml</filename>) defines an input
                    parameter for this servlet named <filename>log4j.properties</filename>,
                    whose value
                    is translated to a context-relative path and defines a file where properties
                    should be read from. For example, the following fragment of <filename>web.xml</filename>
                    file
                    defines that &log4j; properties should
                    be read from folder: <filename>/WEB-INF/myapplication-log4j.properties</filename>,
                    relative to the unpacked web application base.
                    </para>
                    
                    <informalexample>
                    <programlisting><![CDATA[
<servlet-name>MyFilter</servlet-name>
<servlet-class>
    com.dawidweiss.carrot.filter.myfilterpackage.MyFilter
</servlet-class>
<init-param>
  <param-name>log4j.properties</param-name>
  <param-value>/WEB-INF/myapplication-log4j.properties</param-value>
</init-param>
                    ]]></programlisting>
                    </informalexample>
                    
                    <para>
                    All properties starting with a token <token>TRANSLATE_CONTEXT::</token>
                    will be replaced with real filesystem application path. For example:
                    
                    <screen>log4j.appender.FILE.File=TRANSLATE_CONTEXT::/WEB-INF/carrot2.log</screen>
            
                    could be rewritten to:        
                    
                    <screen>log4j.appender.FILE.File=f:/tomcat/webapps/mywebapp/WEB-INF/carrot2.log</screen>
                
                    If the initialization parameter <filename>log4j.properties</filename>
                    is not defined, default initialization of
                    &log4j; is performed, which <emphasis>does not display any logging messages</emphasis>.
                    If the file cannot be read or does not exist, default initialization is performed as well.
                    </para>
                </listitem>
            </itemizedlist>
            
            </para>
            
            <note>
                <para>
                Template servlets from the common &carrot; library automatically detect the 
                presence of <filename>log4j.properties</filename> parameter and initialize &log4j;
                accordingly.
                </para>
            </note>

            <!-- }}} -->
        </section>
        
        <section id="sect:command-line-tools">
            <title>Command-line tools</title>
            <!-- {{{ -->
            <para>
            The common library contains a set of useful command-line programs, which can be
            used for debugging or testing purposes. In order to use these programs, make
            sure you have the shared JAR library in <envar>CLASSPATH</envar>.
            This can be for instance
            achieved by adding: <option>-Djava.ext.dirs=runtime/shared/lib</option> to the
            invokation line of Java (assuming we are in the top directory of the
            distribution). A handful or shell scripts to the most frequently used commands is
            also provided in <filename>bin</filename> directory of the distribution.
            </para>
            
            <itemizedlist>
                <listitem><para>
                <classname>QueryInputComponent</classname>
                utility can be used to send a search request to a certain input
                component type. For example, typing the command below (assuming the service is running
                at the given URL, should yield 50 snippets from a random snippet
                generator for random seed <parameter>anyquery</parameter>.
            
                <informalexample>
                <screen>
java -Djava.ext.dirs=runtime/shared/lib
   com.dawidweiss.carrot.tools.QueryInputComponent
      http://localhost:8080/snippet-generator/service/random 50 anyquery
                </screen>
                </informalexample>
            
                </para></listitem>
                
                <listitem><para>
                    <classname>QueryFilterComponent</classname> utility can be used to send
                    search result data stream to a certain filter or output component.
                    </para>
                    <para>
                    The program expects an input file, which should conform filter/ output
                    component's contract (for instance - it should represent search results
                    data). The result returned by the component is written to standard
                    output.
                    <informalexample>
                    <screen>
java -Djava.ext.dirs=runtime/shared/lib
   com.dawidweiss.carrot.tools.QueryFilterComponent 
      http://localhost:8080/text-only/service
                    </screen>
                    </informalexample>
                </para></listitem>    
            </itemizedlist>
            <para>
            Command line tools can be combined to form processing chains using standard
            shell pipelines.
            </para>
            <!-- }}} -->
        </section>

        <!-- }}} -->
    </section>
    
    
    <section id="sect:runtimeenvironment">
        <title>Development runtime environment</title>
        <!-- {{{ -->
        <para>
        The runtime environment for components should be a Servlet container
        compliant with
        Servlet/JSP specifications (at the moment we use &tomcat;, see
        <filename>/runtime/server.info</filename> file for details).
        </para>

        <para>
        A &quot;standard&quot; preconfigured runtime environment for &carrot;
        can be also downloaded from the project Web site:
        <ulink url="http://www.cs.put.poznan.pl/dweiss/carrot/xml/download.xml?lang=en" />.
        </para>

        <!-- }}} -->
    </section>

</chapter> 


