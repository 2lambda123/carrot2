<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC 
    "-//Dawid Weiss//DTD DocBook V3.1-Based Extension for XML and graphics inclusion//EN" 
    "carrot-docbook-extensions.dtd">
  
<chapter id="chapter:architecture">
    <title>Architecture</title>
    
    <section id="sect:components-and-data-flow">
        <title>Components and data flow</title>

        <!-- {{{ -->
        <para>
        &carrot;'s architecture is based on certain definitions of <glossterm>data
        exchange formats</glossterm> and interaction among <glossterm>components</glossterm>.
        </para>

        <pasteFigure src="components-dataflow.png" width="4in">
        Components and data flow in &carrot;
        </pasteFigure>

        <para>
        There are four fundamental component types in the framework: input component,
        output component, filter component and controller component. A typical flow of
        information among them is presented in 
        <xref linkend="figure:components-dataflow" />. 
        Central to this concept is the controller component, which transforms
        input stimuli (like user's search query) into a format acceptable by
        the input components and then mediates in data exchange among filter components,
        eventually returning the final reasult back to the outside world
        using the output component. The last component is usually some sort of visualization
        of the result (in case of search results clustering presentation of the discovered
        groups of documents).
        </para>

        <para>
        An established <glossterm>process</glossterm> of data flow from the search
        request to the final output is one of &carrot;'s strongest features. 
        Designers have the freedom to make up their own intermediate data
        formats (passed between components), but they can still use the controller
        component and any other part of the system. Obviously, components
        combined together into a processing chain must be able to interpret each other's
        result, but this is accomplished by defining &xmlschema;s for particular
        types of data.
        </para>

        <para>
        One could notice that this results in a seemingly excessive communication between the controller
        and other components in a processing chain. This could be replaced by a &quot;waterfal&quot;
        scheme, where every component's output would be directly passed to the following
        component's input. Such situation is of course possible, but it would require
        that information about the entire process is embedded in the request at the beginning
        and that components share the functionality of the controller (i.e. send data processing
        requests to other components).  
        We decided to make component designers' life easier and went for an easier &quot;centralized&quot;
        model, where all information is mediated by the controller component. &http; protocol
        used for data exchange also supports our choice, as it is inherently bound to 
        query-response paradigm.
        </para>
        
        <note>
            <para>
            In the future, waterfall data exchange specification as described above
            may be included in &carrot; &ndash; controller component will automatically
            detect the components capable of using it. 
            </para>
        </note>
        <!-- }}} -->
    </section>

    <section id="sect:communication-method">
        <title>Communication methods</title>
        <!-- {{{ -->       
        <para>
        In <xref linkend="sect:components-and-data-flow"/>, we described <emphasis>where</emphasis>
        data and processing takes place in the framework. This section explains
        <emphasis>how</emphasis> it is sent and received by individual components.
        </para>

        <para>
        At first, data exchange among &carrot;'s components was realized using
        &xml; files transferred over the network using &http; protocol's &post;
        method. This method is very well suitable for research application and
        distribution of components but adds a great overhead to processing. Recently,
        plans have been made to extend the current &carrot; specification with 
        <emphasis>local</emphasis> binding possibility, so that all data is pipelined
        locally without the cost of serialization and network transfers. 
        </para>
        
        <section id="sect:http-communication">
            <title>&http; &post; communication mode</title>
            <!-- {{{ -->
            
            <para>
            HTTP protocol was the first method of communication among
            components in &carrot; architecture.
            The following points must be respected:
    
                <itemizedlist>
                    <listitem>
                    <para>
                        The data stream (query for input components,
                        result stream for filters and outputs), should be sent
                        as a parameter of a &http; &post; request.
                        The parameter's name should be <parameter>carrot-request</parameter> 
                        for input components and  
                        <parameter>carrot-xchange-data</parameter> for
                        filter and output components.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    &http; &get; request is reserved for future extensions of the framework.
                    Service &url; of a component should not use it for any private 
                    communication.
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    &http; &post; request parameters (&xml; files)
                    must be encoded using &utf8; character
                    encoding. &http; request/ response content type should also be
                    set to &utf8;. 
                    </para>
                    </listitem>
                    
                    <listitem>
                    <para>
                    Normal &http; <parameter>Content-encoding</parameter> headers
                    should be respected. In particular, <acronym>GZIP</acronym>
                    compression, if supported by the caller (controller component),
                    should be utilized to save network bandwidth.
                    </para>
                    </listitem>
                </itemizedlist>
            </para>

            <para>
            By implicit assumption, all components that expose
            a &http; &post; interface must also define at least one Uniform
            Resource Locator (&url;s) where their services will be accessible to
            other components. These service &url;s are then used in specifying
            a <link linkend="sect:component-descriptor-file">component descriptor</link>.
            </para>

            <para>
            The controller component guarantees no special handling
            in case of erraneous execution of a
            chained component. In general, an empty, or corrupted response
            stream indicates such situation, but the controller may
            just propagate such empty response to components further down the chain.
            However, if any component send an error &http; response header, the
            controller component will interrupt any remaining processing and
            signal the problem to the outside environment (user).
            </para>

        </section>
        <!-- }}} -->

        <section id="sect:local-communication">
            <title>Local communication mode</title>
            <!-- {{{ -->
            <para>
            This mode of communication among components is still at the
            planning stage.
            </para>
        </section>
        <!-- }}} -->
    </section>    
    <!-- }}} -->

    <section id="sect:input-component">
        <title>Input component type</title>
        <!-- {{{ -->
        <para>
        The input component is in charge of accepting a <glossterm>query
        request</glossterm> from the controller. The query request
        may be any data stream and the input component should signal
        an error if it cannot parse and respond to the query.
        At the moment of writing, the only request format
        detected by the implemented input components is described 
        in section <link linkend="sect:mime:x-carrot-clustering-input-query">
        concerning Web Search queries</link>
        and relates to <link linkend="sect:clustering-format">search result processing</link>
        application of the &carrot; framework.
        </para>

        <note>
        <para>
        Once there was a specification of accepted and returned 
        streams encoded as &mime; types. This
        specification has been dropped
        due to lack of interest, but may be revived if needed.
        </para>
        </note>
        <!-- }}} -->
    </section>
    
    
    <section id="sect:filter-components">
        <title>Filter components</title>
        <!-- {{{ -->
        <para>
        Filter components are used to transform one result data set into another. As
        mentioned in section <xref linkend="sect:components-and-data-flow"/>, the exact format
        of input and output data of a filter component is not specified by the
        framework, but depends on the application (the controller only mediates in exchange
        of otherwise binary data). The protocol of data exchange (local or &http;)
        may impose some restrictions, which we describe below.
        </para>
        
        <section>
            <title>Filter components and &http; data exchange</title>

            <para>
            The data stream itself must be sent as a parameter of &http; &post; request named
            <parameter>carrot-xchange-data</parameter>. This implies that binary data
            streams must be encoded according to the &http; &post; specification. 
            </para>
            
            <para>
            The same POST request, which carries &carrot; data can also contain other
            parameters, which can be used to customize processing done by the component.
            These extensions, however, are specific to a given component and therefore not
            subject to this specification. An example of a &http; &post; request specifying
            optional parameter <parameter>myparameter</parameter> is shown in
            <xref linkend="listing:post-request"/>.    
            </para>
            
            <example id="listing:post-request">
                <title>
                A fragment of a &post; request to a service running at &url;
                <parameter>http://localhost:8080/myfilter</parameter>, with additional parameter
                <parameter>myparameter</parameter> set to <literal>myvalue</literal>
                </title>
                <programlisting><![CDATA[@insert-file.head-of-post-request@]]></programlisting>
            </example>
        </section>
        
        <section>
            <title>Filter components and local data exchange</title>
            <para>
            Details have not been established yet.
            </para>
        </section>        
        <!-- }}} -->
    </section>
    
    <section id="sect:output-components">
        <title>Output component type</title>
        <!-- {{{ -->
        <para>
        An output component type is responsible for converting the final data stream into
        some content, which can be returned to the outside environment. Output components
        may also perform additional tasks, not relevant to visualization of the result, like
        dumping the result to a database or sending a confirmation e-mail. Usually, however,
        the output component will turn the raw data processed by input and filter components
        into some content that can be interpreted by the user. 
        </para>
        
        <para>
        There are also some issues specific to the data exchange mode, which we list in
        sections below.
        </para>
        
        <section>
            <title>Output components and &http; data exchange mode</title>
            <para>
            Output component should declare an appropriate <parameter>Content-type</parameter>
            HTTP header for the response stream, according to the returned data stream's format.
            This is very important, because the current implementation of the Web controller
            component simply copies the result to the user's browser.
            </para>
        </section>
        
        <section>
            <title>Output components and local data exchange mode</title>
            <para>
            Details have not been established yet.
            </para>
        </section>
        
        <!-- }}} -->
    </section>

    <section id="sect:controller-components">
        <title>Controller component type</title>
        <!-- {{{ -->
        <para>
        A controller component is the heart of &carrot; framework. It drives the
        process of executing a query by redirecting data from the input, through a
        set of filters and finally to the output component. A controller is also in
        charge of interacting with the &quot;outside world&quot; environment &ndash; this can be
        anything from a set of shell scripts to a fully-fledged web based meta search engine.
        </para>

        <para>
        Controllers should be organized so that they expose information about
        <glossterm>processes</glossterm> of query processing. Such process encompasses a chain of
        components, starting with an input, ending at some output and having filters in
        between. For an example
        of how this can be realized, see the <link linkend="sect:web-controller-component">Web controller
        component</link>'s documentation.
        </para>
        
        <!-- }}} -->
    </section>
    
</chapter>
