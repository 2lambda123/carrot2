
#macro (stringOrEmpty $str)"${esc.java($stringutils.defaultIfEmpty($str, ""))}"#end
#macro (stringOrNull $str)#if ($str)"$esc.java($str)"#else#* *#null#end#end

// APT-generated file.

package ${packageName};

import java.util.*;
import javax.annotation.*;
import org.carrot2.util.attribute.*;

/**
 * Automatically generated descriptor for the bindable type:
 * <code>${sourceType.qualifiedName}</code>. 
 */
@Generated("Generated from ${sourceType.qualifiedName}")
public final class ${sourceType.simpleName}Descriptor implements IBindableDescriptor
{
    /**
     * The bindable class this descriptor was generated for. 
     */
    public final String bindableClassName = "${esc.java($sourceType.qualifiedName)}";

    /**
     * Common attribute prefix for the bindable.
     */
    public final String prefix = "${esc.java($bindable.prefix())}";

    /**
     * A one sentence summary of the element. Could be presented as a header of the tool
     * tip of the corresponding UI component.
     */
    public final String title = #stringOrEmpty($metadata.title);
    
    /**
     * A short label for the element which can be presented as the label of the
     * corresponding UI component.
     */
    public final String label = #stringOrEmpty($metadata.label);

    /**
     * A longer, possibly multi sentence, description of the element. Could be presented
     * as a body of the tool tip of the corresponding UI component.
     */
    public final String description = #stringOrEmpty($metadata.description);

    /**
     * Bindable attributes (fields) that belong to this class only and can be (statically)
     * determined.
     */
    public final static Attributes attributes; 

    /**
     * Attributes that belong to this type only.
     */
    private final static Set<AttributeInfo> ownAttributes;

    /**
     * Attributes that belong to this type or superclasses.
     */
    private final static Set<AttributeInfo> allAttributes;

    /**
     * Attributes that belong to this type or superclasses, lookup dictionary by attribute key.
     */
    private final static Map<String, AttributeInfo> allAttributesByKey;

    /**
     * Attributes that belong to this type or superclasses, lookup dictionary by attribute's 
     * field name.
     */
    private final static Map<String, AttributeInfo> allAttributesByFieldName;

    /**
     * Static initializer for internal collections.
     */
    static
    {
        attributes = new Attributes();

        final Set<AttributeInfo> ownAttrs = new HashSet<AttributeInfo>();
#foreach ($attr in $ownFields)
        ownAttrs.add(attributes.${attr.field.simpleName});
#end

        final Set<AttributeInfo> allAttrs = new HashSet<AttributeInfo>();
#foreach ($attr in $allFields)
        allAttrs.add(${attr.descriptorClass}.attributes.${attr.field.simpleName});
#end

        allAttributes = Collections.unmodifiableSet(allAttrs);
        ownAttributes = Collections.unmodifiableSet(ownAttrs);
        
        final Map<String, AttributeInfo> allAttrsByKey = new HashMap<String, AttributeInfo>();
        final Map<String, AttributeInfo> allAttrsByFieldName = new HashMap<String, AttributeInfo>();
        for (AttributeInfo ai : allAttrs)
        {
            allAttrsByKey.put(ai.key, ai);
            allAttrsByFieldName.put(ai.fieldName, ai);
        }

        allAttributesByKey = Collections.unmodifiableMap(allAttrsByKey);
        allAttributesByFieldName = Collections.unmodifiableMap(allAttrsByFieldName);
    }

    /* IBindableDescriptor */

    @Override 
    public String getPrefix()
    {
        return prefix;
    }

    @Override 
    public String getTitle()
    {
        return title;
    }
    
    @Override 
    public String getLabel()      
    { 
        return label;
    }
    
    @Override 
    public String getDescription() 
    { 
        return description; 
    }

    @Override 
    public Set<AttributeInfo> getOwnAttributes()
    { 
        return ownAttributes;
    }

    @Override 
    public Set<AttributeInfo> getAttributes()
    {
        return allAttributes;
    }

    @Override 
    public Map<String, AttributeInfo> getAttributesByKey()
    {
        return allAttributesByKey;
    }

    @Override 
    public Map<String, AttributeInfo> getAttributesByFieldName()
    {
        return allAttributesByFieldName;
    }


    /* Keys and attribute descriptors. */

    /**
     * Constants for all attribute keys present in the bindable.
     */
    public static final class Keys
    {
#foreach ($attr in $ownFields)
        /** Key for {@link Attributes#$attr.field.simpleName} */
        public static final String $methodutils.asConstant($attr.field.simpleName.toString()) = "${esc.java($attr.key)}";
#end
    }

    /**
     * Bindable attributes (fields) that belong to this class.
     */
    public static final class Attributes
    {
        Attributes() { /* No public instances . */ }

#foreach ($attr in $ownFields)
        /**
         * $!{esc.java($attr.javaDoc)}#if ($attr.inherited)#* *#
         * 
         * @see $attr.inherited.declaringClass#$attr.inherited.field.simpleName
#end
         */
        public final AttributeInfo ${attr.field.simpleName} = 
            new AttributeInfo(
                "${esc.java($attr.key)}",
                "${esc.java($attr.declaringClass)}",
                "${esc.java($attr.field.simpleName)}",
                #stringOrNull($attr.javaDoc),
                #stringOrNull($attr.label),
                #stringOrNull($attr.title),
                #stringOrNull($attr.description),
                #stringOrNull($attr.group),
                #if ($attr.level)org.carrot2.util.attribute.AttributeLevel.${attr.level.toString().toUpperCase()}#else#* *#null#end,
                #if ($attr.inherited)${attr.inherited.descriptorClass}.attributes.${attr.inherited.field.simpleName}#else#* *#null#end#* *#
            );
#if ($velocityHasNext )##emit EOL between fields

#end
#end

#foreach ($i in $nestedFields)
        /**
         * Attributes of a nested bindable type {@link ${i.fieldElement}}.
         */
        public final ${i.fieldElement}Descriptor.Attributes ${i.field.simpleName} =
            ${i.fieldElement}Descriptor.attributes;
#if ($velocityHasNext )##emit EOL between methods

#end
#end
    }

    /**
     * The builder pattern for collecting attributes of this bindable (not including any possible
     * sub-bindables, but anything that can be resolved statically).
     */
    public static final class AttributeBuilder
    {
        public final Map<String, Object> map;

        AttributeBuilder(Map<String, Object> map)
        {
            this.map = map;
        }

        public Map<String, Object> build()
        {
            return map;
        }

#foreach ($i in $ownFields)
        /**
         * ${esc.java($i.javaDoc)}
         */
        public AttributeBuilder ${i.field.simpleName}($i.field.asType() value)
        {
            map.put("$i.key", value);
            return this;
        }
#if ($velocityHasNext )##emit EOL between methods

#end
#end

#foreach ($i in $nestedFields)
        /**
         * Returns an attribute builder for a nested bindable type
         * {@link ${i.fieldElement}}, backed by the same attribute map
         * as the current builder.
         */
        public ${i.fieldElement}Descriptor.AttributeBuilder ${i.field.simpleName}()
        {
            return ${i.fieldElement}Descriptor.attributeBuilder(map);
        }
#if ($velocityHasNext )##emit EOL between methods

#end
#end
    }

    /**
     * Return an attribute builder for this bindable. Provides type-safe checking alternative to
     * using raw attribute keys.
     */
    public static AttributeBuilder attributeBuilder()
    {
        return new AttributeBuilder(new HashMap<String, Object>());
    }

    /**
     * Return an attribute builder for this bindable. Provides type-safe checking alternative to
     * using raw attribute keys.
     * 
     * @param attributeValues An existing map which should be used to collect attribute values.
     */
    public static AttributeBuilder attributeBuilder(Map<String, Object> attributeValues)
    {
        return new AttributeBuilder(attributeValues);
    }
}
